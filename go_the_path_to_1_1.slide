The Path to Go 1.1
language, tools, and performance
19:00 28 Mar 2013
Tags: go1.1, go

Jesse Szwedko
Software Engineer, ModCloth
j.szwedko@modcloth.com
@jesse_szwedko

Sheena McCoy
Software Engineer, ModCloth
sp.mccoy@modcloth.com
@sheenapmccoy

* Method Value
- Functions that have been bound to a specific receiver value

    var w bufio.Writer
    f := w.Write //func(p []byte) (n int, err error) with implicit receiver
    n, err := f([]byte{1,2,3}) //writes the byte array to w

- Not to be confused with method expressions
    var w bufio.Writer
    f := (*bufio.Writer).Write  //func (w *bufio.Writer, p []byte) (n int, err error)
    n, err := f(w, []byte{1,2,3}) //writes the byte array to w

Useful for passing struct methods to APIs requiring a callback (e.g.
[[http://golang.org/pkg/net/http/#ServeMux.ServeHTTP][`http.ServeMux#ServeHTTP`]]).
Previously this would require wrapping in an anonymous function.

* Method Value
.play methods.go /START OMIT/,/END OMIT/

* Return Requirements
Functions ending in [[http://tip.golang.org/ref/spec#Terminating_statements][terminating statements]] no longer require a panic() or return

.code returns.go /START OMIT/,/END OMIT/

You can use `go vet` to find unreachable code

* Standard library changes
- [[http://tip.golang.org/doc/go1.1][Many]]

* reflect.MakeFunc
    func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value

Execution of generated function
- converts its arguments to a list of Values args.
- runs results := fn(args).
- returns the results as a slice of Values, one per formal result.

Allows for implementation of pseudo-generic functions. Could use to generate
generic data structures (collection of functions with struct as first
parameter).

* reflect.MakeFunc
.play reflect.go /START OMIT/,/END OMIT/

* reflect.Select

    const (
            _               SelectDir = iota
            SelectSend              // case Chan <- Send
            SelectRecv              // case <-Chan:
            SelectDefault           // default
    )

    type SelectCase struct {
        Dir  SelectDir // direction of case
        Chan Value     // channel to use (for send or receive)
        Send Value     // value to send (for send)
    }

    func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)

* Muxing Select Go 1
.play pre-select.go /START OMIT/,/END OMIT/

* Muxing Select Go 1.1 (reflect.Select)
.play post-select.go /START OMIT/,/END OMIT/

* Muxing in Newsqueak
.code newsqueak-select.ns

Maybe someday.

[[http://www.youtube.com/watch?v=hB05UFqOtFA][CSP in Newsqueak]]

* Other Language Changes
- Integer division by zero
- Surrogates in Unicode literals

* Backwards "Incompatible" Changes
- Ints are now 64-bit on 64-bit platforms
- UTF-16 surrogate half values are correctly considered illegal
- Assembly functions need to be revised to adjust frame pointer offsets (use go vet)
- Division by constant 0 is a compile-time error instead of runtime
- [[http://golang.org/pkg/net/][net]] package structs now have a Zone field which breaks untagged struct literals (use go fix)
- [[http://golang.org/pkg/time/][time]] package now returns nanosecond precision
- [[http://golang.org/doc/go1compat.html][Go Compatibility]] 

* Implemtation and Tool Changes
- Command-line flag parsing
- Size of int on 64-bit platforms
- Unicode
- The gc assemblers
- Changes to the go command
- Changes to the go test command
- Changes to the go fix command

* Performance
Typical improvements relative to Go 1.0 seem to be about 30%-40%
- The gc compilers generate better code in many cases, most noticeably for floating point on the 32-bit Intel architecture.
- The gc compilers do more in-lining, including for some operations in the run-time such as append and interface conversions.
- There is a new implementation of Go maps with significant reduction in memory footprint and CPU time.
- The garbage collector has been made more parallel, which can reduce latencies for programs running on multiple CPUs.
- The garbage collector is also more precise, which costs a small amount of CPU time but can reduce the size of the heap significantly, especially on 32-bit architectures.
- Due to tighter coupling of the run-time and network libraries, fewer context switches are required on network operations.

* Current State of 1.1 Release
.link http://blog.golang.org/2013/03/the-path-to-go-1.html "in the coming weeks."
.iframe http://swtch.com/~rsc/go11.html 400 1000
